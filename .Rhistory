order=2
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
plot(mesh)
mesh <- refine.MESH.2D(mesh, maximum_area = 5000)
plot(mesh)
data = log(MeuseData[,7])
covariates = matrix(1,nrow=length(data),ncol=2)
covariates[,1] = sqrt(MeuseData[,9])
covariates[,2] = (MeuseData[,8])
#  set up the FEM basis object and plot it
# NO ORDER
basisobj = create.FEM.basis(mesh, order)
#  smooth the data without covariates
lambda = 10^3.5
#Rprof("smooth.out", memory.profiling = TRUE)
ZincMeusefd1 = smooth.FEM.basis(locations = MeuseData[,c(2,3)],
observations = data, basisobj = basisobj,
lambda = lambda, GCV = FALSE, covariates = covariates, CPP_CODE = TRUE)
plot(ZincMeusefd1$felsplobj, num_refinements = 10)
install.packages("fda")
library(FEMr)
#setwd("~/workspace/RPDE/RScripts")
data(MeuseData)
data(MeuseBorder)
order=2
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
plot(mesh)
mesh <- refine.MESH.2D(mesh, maximum_area = 5000)
plot(mesh)
data = log(MeuseData[,7])
covariates = matrix(1,nrow=length(data),ncol=2)
covariates[,1] = sqrt(MeuseData[,9])
covariates[,2] = (MeuseData[,8])
#  set up the FEM basis object and plot it
# NO ORDER
basisobj = create.FEM.basis(mesh, order)
#  smooth the data without covariates
lambda = 10^3.5
ZincMeusefd1 = smooth.FEM.basis(locations = MeuseData[,c(2,3)],
observations = data, basisobj = basisobj,
lambda = lambda, GCV = FALSE, covariates = covariates, CPP_CODE = TRUE)
plot(ZincMeusefd1$felsplobj, num_refinements = 10)
plot(ZincMeusefd1$felsplobj, num_refinements = 10)
ZincMeusefd1
plot(ZincMeusefd1$felsplobj, num_refinements = 10)
library(FEMr)
load("mesh.example.2D")
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
#  smooth the data without covariates
lambda = c(10^-2, 10^-1, 0.5, 5, 10)
## data diviso in due
BC = NULL
# Isotropic smoothing
PDE_parameters_iso = list(K = matrix(c(1,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_iso)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys)
plot(FEM_CPPfit.FEM)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
load("mesh.example.2D")
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
#  smooth the data without covariates
lambda = c(10^-2, 10^-1, 0.5, 5, 10)
## data diviso in due
BC = NULL
# Isotropic smoothing
PDE_parameters_iso = list(K = matrix(c(1,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_iso)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys)
plot(FEM_CPP$fit.FEM)
library(FEMr)
load("mesh.example.2D")
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
data()
library(FEMr)
?smooth.FEM.basis
remove.packages("FEMr", lib="~/R/x86_64-pc-linux-gnu-library/3.2")
devtools::install_github("eardi/FEMr")
library(FEMr)
library(FEMr)
data(mesh.2D.simple)
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys)
plot(FEM_CPP_PDE$fit.FEM)
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys, GCV = TRUE)
FEM_CPP_PDE$edf
FEM_CPP_PDE$GCV
plot(FEM_CPP_PDE$GCV)
library(FEMr)
data(mesh.2D.simple)
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10, 100)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys, GCV = TRUE)
plot(FEM_CPP_PDE$GCV)
plot(FEM_CPP_PDE$stderr)
plot(FEM_CPP_PDE$edf)
library(FEMr)
data(mesh.2D.simple)
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10, 100)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys, GCV = TRUE)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
data(mesh.2D.simple)
plot(mesh)
observations = sin(pi*mesh$nodes[,1]) + rnorm(n = nrow(mesh$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10, 100)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys, GCV = TRUE)
plot(FEM_CPP_PDE$fit.FEM)
names((FEM_CPP_PDE))
names((FEM_CPP_PDE$beta))
?regexp
?FDA
??FDA
demo(fdarm)
library(fda)
demo(fdarm)
demo(fdarm)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
library(FEMr)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
## plot the FEM object representing the misfit
image(ZincMeuse$PDEmisfit.FEM)
library(FEMr)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
## plot of the FEM object representing the fitted function
image(ZincMeuse$fit.FEM)
ZincMeuse$fit.FEM
options(download.file.method = "wininet")
library(devtools)
install_github("eardi/FEMr")
options(download.file.method = "libcurl")
install_github("eardi/FEMr")
options(download.file.method = "wininet")
install_github("eardi/FEMr")
install_github("eardi/FEMr")
install_github('eardi/FEMr', host = "api.github.com")
install.packages("httr")
install.packages("httr")
install.packages("httr")
install_github("eardi/FEMr")
install_github("eardi/FEMr")
library(devtools)
install_github("eardi/FEMr")
install_github("eardi/FEMr")
install_github("eardi/FEMr")
install.packages("rcurl")
install.packages("rcurl")
library(RCurl)
library(httr)
set_config( config( ssl.verifypeer = 0L ) )
install.packages("rcurl")
install_github("eardi/FEMr")
set_config( config( ssl_verifypeer = 0L ) )
install_github("eardi/FEMr")
set_config( config( ssl_verifypeer = 0L ) )
install_github("eardi/FEMr")
set_config( config( ssl_verifypeer = 0L ) )
install_github("eardi/FEMr")
set_config( config( ssl_verifypeer = 0L ) )
library(RCurl)
set_config( config( ssl_verifypeer = 0L ) )
library(httr)
set_config( config( ssl_verifypeer = 0L ) )
install_github("eardi/FEMr")
library(devtools)
install_github("eardi/FEMr")
set_config( config( ssl.verifypeer = 0L ) )
library(devtools)
install_github("eardi/FEMr")
set_config( config( ssl_verifypeer = 0L ) )
library(devtools)
install_github("eardi/FEMr")
install.packages(c("curl", "evaluate", "git2r", "jsonlite", "lattice", "manipulate", "mime", "R6", "Rcpp", "RcppArmadillo", "rgl", "scales", "xml2"))
library("devtools", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
install_github("eardi/FEMr")
install_github("hadley/devtools")
devtools::install_github("hadley/devtools")
library(FEMr)
?smooth.FEM.PDE.SV.basis
data(mesh.2D.rectangular)
observations = sin(0.2*pi*mesh.2D.rectangular$nodes[,1]) + rnorm(n = nrow(mesh.2D.rectangular$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh.2D.rectangular, 2)
# Smoothing coefficient
lambda = c(10^-2)
K_func<-function(points)
{
mat<-c(0.01,0,0,1)
as.vector(0.5*mat %*% t(points[,1]^2))
}
b_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(0), nrow(points))
}
# Space-varying smoothing
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
FEM_CPP_PDE = smooth.FEM.PDE.SV.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
data(MeuseData)
data(MeuseBorder)
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
plot(mesh)
data = log(MeuseData[,7])
basisobj = create.FEM.basis(mesh, order)
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data, basisobj = basisobj, lambda = lambda)
plot(ZincMeuse$fit.FEM)
library(FEMr)
data(mesh.2D.simple)
plot(mesh.2D.simple)
observations = sin(pi*mesh.2D.simple$nodes[,1]) + rnorm(n = nrow(mesh.2D.simple$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh.2D.simple, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
data(mesh.2D.simple)
plot(mesh.2D.simple)
observations = sin(pi*mesh.2D.simple$nodes[,1]) + rnorm(n = nrow(mesh.2D.simple$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh.2D.simple, 2)
# Smoothing coefficients
lambda = c(10^-2, 10^-1, 0.5, 5, 10)
# Anysotropic smoothing
PDE_parameters_anys = list(K = matrix(c(0.01,0,0,1), nrow = 2), b = c(0,0), c = 0)
FEM_CPP_PDE = smooth.FEM.PDE.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters_anys)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
data(mesh.2D.rectangular)
observations = sin(0.2*pi*mesh.2D.rectangular$nodes[,1]) +
rnorm(n = nrow(mesh.2D.rectangular$nodes), sd = 0.1)
basisobj = create.FEM.basis(mesh.2D.rectangular, 2)
# Smoothing coefficient
lambda = c(10^-2)
K_func<-function(points)
{
mat<-c(0.01,0,0,1)
as.vector(0.5*mat %*% t(points[,1]^2))
}
b_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(0), nrow(points))
}
# Space-varying smoothing
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
FEM_CPP_PDE = smooth.FEM.PDE.SV.basis(observations = observations,
basisobj = basisobj, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
setwd("~/git/fdaPDE")
setwd("~/git/fdaPDE")
roxygen2::roxygenise()
roxygen2::roxygenise()
library("roxygen2", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.2")
roxygenise()
setwd("~/git/fdaPDE")
setwd("~/git/fdaPDE/R")
roxygenise()
setwd("~/git/fdaPDE")
roxygenise()
remove.packages("fdaPDE", lib="~/R/x86_64-pc-linux-gnu-library/3.2")
install.packages("~/git/fdaPDE_0.1-1.tar.gz", repos = NULL, type = "source")
?fdaPDE
??fdaPDE
library(fdaPDE)
??fdaPDE
?fdaPDE
?smooth.FEM.basis
data(MeuseData)
data(MeuseBorder)
## Create a triangular mesh for these data with the provided boundary and plot it
order=1
mesh <- create.MESH.2D(nodes = MeuseData[,c(2,3)], segments = MeuseBorder, order = order)
plot(mesh)
## Create the Finite Element basis
FEMbasis = create.FEM.basis(mesh, order)
## Estimate zync field without using covariates, setting the smoothing parameter to 10^3.5
data = log(MeuseData[,"zinc"])
lambda = 10^3.5
ZincMeuse = smooth.FEM.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda)
## Plot the estimated spatial field
plot(ZincMeuse$fit.FEM)
# Now repeat the analysis using as covariates the square root of the log-distance
# from river \code{sqrt(dist.log(m))} and the altitude \code{elev}
desmat = matrix(1,nrow=nrow(MeuseData),ncol=2)
desmat[,1] = sqrt(MeuseData[,"dist.log(m)"])
desmat[,2] = MeuseData[,"elev"]
ZincMeuseCovar = smooth.FEM.basis(observations = data, covariates = desmat,
FEMbasis = FEMbasis, lambda = lambda)
# Plot of the non parametric part (f) of the regression model y_i = beta_1 x_i1 + beta_2 x_i2 + f
plot(ZincMeuseCovar$fit.FEM)
eval(ZincMeuseCovar$fit.FEM, c(0,0))
?eval.FEM
eval.FEM(ZincMeuseCovar$fit.FEM, c(1,1))
eval.FEM(ZincMeuseCovar$fit.FEM, rbind(c(1,1)))
plot(mesh)
axis()
axis(1)
axis(2)
eval.FEM(ZincMeuseCovar$fit.FEM, rbind(c(180000,331000)))
eval.FEM(ZincMeuseCovar$fit.FEM, c(180000,331000))
as.matrix(c(180000,331000))
is.vector(c(180000,331000))
rbind(c(180000,331000))
remove.packages("fdaPDE", lib="~/R/x86_64-pc-linux-gnu-library/3.2")
install.packages("~/git/fdaPDE_0.1-1.tar.gz", repos = NULL, type = "source")
