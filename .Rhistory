K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
output = smooth.FEM.PDE.SV.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters, BC = BC)
#OBS space varying smoothing function
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
output = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters, BC = BC)
plot(output)
?smooth.FEM.PDE.sv.basis
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = observations,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = observations,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
# Choose the order of the FE (either 1 or 2)
order = 1
num_subdivisions = 40
x = seq(from = -100, to = 100, length.out = num_subdivisions)
y = seq(from = -100, to = 100, length.out = num_subdivisions)
nodes = expand.grid(x, y)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
#mesh<-refine.MESH.2D(mesh,maximum_area = 0.05, delaunay = T)
#plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
BC = NULL
#BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
#Indices= BorderIndices
#Values = rep(x = 0, times = length(Indices))
#BC = list(Indices = Indices, Values = Values)
## Due tipologie input
# output = smooth.LAPLACE.basis(locations  = locations, observations = data,
#                                    basisobj = basisobj, lambda = lambda, covariates = covariates,
#                                    CPP_CODE = FALSE)
# output = smooth.LAPLACE.basis(locations  = as.matrix(locations), observations = data,
#                               basisobj = basisobj, lambda = lambda, covariates = covariates,
#                               CPP_CODE = FALSE)
#OBS space varying smoothing function
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
# Choose the order of the FE (either 1 or 2)
order = 1
x = seq(from = -100, to = 100, length.out = num_subdivisions)
y = seq(from = -100, to = 100, length.out = num_subdivisions)
nodes = expand.grid(x, y)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
#mesh<-refine.MESH.2D(mesh,maximum_area = 0.05, delaunay = T)
#plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
BC = NULL
#BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
#Indices= BorderIndices
#Values = rep(x = 0, times = length(Indices))
#BC = list(Indices = Indices, Values = Values)
## Due tipologie input
# output = smooth.LAPLACE.basis(locations  = locations, observations = data,
#                                    basisobj = basisobj, lambda = lambda, covariates = covariates,
#                                    CPP_CODE = FALSE)
# output = smooth.LAPLACE.basis(locations  = as.matrix(locations), observations = data,
#                               basisobj = basisobj, lambda = lambda, covariates = covariates,
#                               CPP_CODE = FALSE)
#OBS space varying smoothing function
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 0.05, delaunay = T)
plot(mesh)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 0.3, delaunay = T)
mesh<-refine.MESH.2D(mesh,maximum_area = 1, delaunay = T)
mesh<-refine.MESH.2D(mesh,maximum_area = 1, delaunay = T)
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 1, delaunay = T)
plot(mesh)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 4, delaunay = T)
plot(mesh)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
# If you want to refine the mesh, uncomment following two lines
mesh<-refine.MESH.2D(mesh,maximum_area = 5, delaunay = T)
plot(mesh)
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
# If you want to refine the mesh, uncomment following two lines
mesh<-refine.MESH.2D(mesh,maximum_area = 10, delaunay = T)
plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
BC = NULL
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
order = 2
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
# If you want to refine the mesh, uncomment following two lines
mesh<-refine.MESH.2D(mesh,maximum_area = 10, delaunay = T)
plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
BC = NULL
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
#BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
#Indices= BorderIndices
#Values = rep(x = 0, times = length(Indices))
#BC = list(Indices = Indices, Values = Values)
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
#setwd("~/workspace/RPDE/RScripts")
# Create a gid of points
x = seq(from = -100, to = 100, length.out = num_subdivisions)
y = seq(from = -100, to = 100, length.out = num_subdivisions)
nodes = expand.grid(x, y)
# Choose the order of the FE (either 1 or 2)
order = 1
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
# If you want to refine the mesh, uncomment following two lines
mesh<-refine.MESH.2D(mesh,maximum_area = 10, delaunay = T)
plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
BC = NULL
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
#BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
#Indices= BorderIndices
#Values = rep(x = 0, times = length(Indices))
#BC = list(Indices = Indices, Values = Values)
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
?smooth.FEM.basis
setwd("/mhome/stats/s/el425/git/FEMr/R")
setwd("/mhome/stats/s/el425/git/FEMr")
roxygen2::roxygenise()
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
BC_indices= BorderIndices
BV_values = rep(x = 0, times = length(Indices))
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
BC_indices= BorderIndices
BV_values = rep(x = 0, times = length(Indices))
# Neumann Homogeneous Boundary Conditions (implicitely defined by non imposing dirichlet BC)
BC = NULL
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
BC_indices= BorderIndices
BC_values = rep(x = 0, times = length(BC_indices))
BC = list(BC_indices = BC_indices, BC_values=BC_values)
# Choose the order of the FE (either 1 or 2)
order = 1
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
# Neumann Homogeneous Boundary Conditions (implicitely defined by non imposing dirichlet BC)
BC = NULL
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
BC_indices= BorderIndices
BC_values = rep(x = 0, times = length(BC_indices))
BC = list(BC_indices = BC_indices, BC_values=BC_values)
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data, BC = BC,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
# Neumann Homogeneous Boundary Conditions (implicitely defined by non imposing dirichlet BC)
BC = NULL
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
BC_indices= BorderIndices
BC_values = rep(x = 0, times = length(BC_indices))
BC = list(BC_indices = BC_indices, BC_values=BC_values)
plot(FEM_CPP_PDE$fit.FEM)
# Neumann Homogeneous Boundary Conditions (implicitely defined by non imposing dirichlet BC)
BC = NULL
# To impose some dirichlet boundary conditions please uncomment the next 6 rows
BorderIndices = (1:length(mesh$nodesmarker))[mesh$nodesmarker==1]
BC_indices= BorderIndices
BC_values = rep(x = -2, times = length(BC_indices))
BC = list(BC_indices = BC_indices, BC_values=BC_values)
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data, BC = BC,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
library(FEMr)
#setwd("~/workspace/RPDE/RScripts")
# Create a gid of points
x = seq(from = -100, to = 100, length.out = num_subdivisions)
y = seq(from = -100, to = 100, length.out = num_subdivisions)
nodes = expand.grid(x, y)
# Choose the order of the FE (either 1 or 2)
order = 1
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
# If you want to refine the mesh, uncomment following two lines
# mesh<-refine.MESH.2D(mesh,maximum_area = 10, delaunay = T)
# plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 20, delaunay = T)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 15, delaunay = T)
mesh<-refine.MESH.2D(mesh,maximum_area = 15, delaunay = T)
mesh<-refine.MESH.2D(mesh,maximum_area = 15, delaunay = T)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 15, delaunay = T)
#
plot(mesh)
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
mesh<-refine.MESH.2D(mesh,maximum_area = 10, delaunay = T)
#
plot(mesh)
# Choose the order of the FE (either 1 or 2)
order = 2
# Create a mesh from the grid of points and plot it
mesh<-create.MESH.2D(nodes=nodes, order = order)
plot(mesh)
# If you want to refine the mesh, uncomment following two lines
# mesh<-refine.MESH.2D(mesh,maximum_area = 10, delaunay = T)
# plot(mesh)
FEMbasis = create.FEM.basis(mesh, order)
lambda = 1
observation <-function(nodes)
{
3*cos(0.2*nodes[,1])*cos(0.2*nodes[,2]) + rnorm(nrow(nodes), mean = 0, sd = 1)
}
data = observation(nodes)
#create space varying smoothing coefficients (decading when far from zero)
K_func<-function(points)
{
mat<-c(1,0,0,1)/300
as.vector(mat %*% t(points[,1]^2+points[,2]^2))
}
beta_func<-function(points)
{
rep(c(0,0), nrow(points))
}
c_func<-function(points)
{
rep(c(0), nrow(points))
}
u_func<-function(points)
{
rep(c(1), nrow(points))
}
# Group all coefficients in one object
PDE_parameters = list(K = K_func, beta = beta_func, c = c_func, u = u_func)
#Compute and print spatial field
FEM_CPP_PDE = smooth.FEM.PDE.sv.basis(observations = data,
FEMbasis = FEMbasis, lambda = lambda, PDE_parameters = PDE_parameters)
plot(FEM_CPP_PDE$fit.FEM)
roxygen2::roxygenise()
